{"pages":[],"posts":[{"title":"靠PE选股有用吗??","text":"PE, ROE, DY到底哪一个才有用?? 价值投资者们推崇低PE, 用最高的安全边际来买股. 成长型投资者又不这么认为了, 他们就认为成长中的公司就算有高PE也是没关系的, 股票里没有对与错就只有最适合自己的策略. 言归正题, 到底哪一个指标才能帮助你找到能赚钱的好股呢? 我们来探讨一下. 隆重介绍 klsequant 股票回测网络程序今天我就像大家介绍我在MCO期间写的一个网络程序 https://www.klsequant.com 这个程序有什么功能呢? 它能拿来做什么? 能吃的吗? 它的功能是, 当你想出或找到一个选股策略时, 例如当PE小于10和ROE大于20的时候买入. 然后你就能用klsequant来回测你的选股策略, 来评估这个策略过去的表现. 这个程序会显示过去10年的表现, 它用的数据是2010-2019每一个在马来西亚上市的股票. 这个网络程序是基于Python Flask框架来develope的. 虽然以前经常用Python来做分析可是没有试过在web的环境用Python, 这也算是对我自己的一个技术挑战. Code好后我用的是 pythonanywhere 来host这个程序. 如果你也有用Python的话可以看看这个服务, 价钱合理, 也有免费的配套. 用户界面 UI 先来简单介绍一下界面, 这里有总共14个选项给你, Maximum number of Shares(最高持股数量) 这栏是必填的, 其他选项就根据你选股策略来填, 不需要的就空着罢了. Demo话不多说, 先来个demo. 我想回测我的选股策略, 我的策略如下 PE 小于 10 ROE 大于 15 DY 大于 3 如果某个股票符合这个条件的话, 程序就会”买入”. 一个月后, 重复这个过程, 如果上个月”买入”的股项还符合你的策略, 那么程序就会继续保留这个股票, 如果已经不符合了, 程序就会把那个股票”卖出”. 如果你想玩更长期的, 可以在下面的选项选weekly, monthly, 最久的是yearly. 这就是你调配仓位的频率, 就要看你的策略是长期还是短期策略咯. 你也可以实验一下到底长期还是短期投资比较好. 到底我的选股策略表现如何呢? 回测结果是这个策略的年华回酬是36%, 算是非常好的回酬了. 而且这个策略也跑赢了大市(红线是大马综合指数的回酬). Capital RM1,000的意思是起初资金是1千. 再仔细一点的解释如下 绿线代表的是你策略的资金成长线, 红线代表大马综合指数的资金成长. 要怎么评估你的策略好不好呢, 一个常用的策略是用大市来比较. (如果你的策略跑输大市你不如直接买马股ETF更好) Maximum return是期间这个策略最大的一个收益, 这里显示是48.3%, 意思是说这期间有一个股票在一个月里达到了48.4%的回酬. Minimum return, 最低回酬是-13.81%, 这也不错嘛最大回酬远远比最低回酬高. Average return是指你平均每一个交易的回酬是多少. CAGR就是年化回酬, 这策略有着36%的年化回酬. 话说这策略也大大的跑赢了指数, 10年间这个策略会把你的RM1,000变成RM16,000, 反而指数只能把你的RM1,000变成RM1,131. 所以这个策略到底抓到了什么股呢? 这个表格就显示了期间所有被这个策略抓到的股票. 从这里你可以大概知道你策略选出来的公司是怎么样的. 你也许会好奇为什么一下月份只持有3个股票, 这是因为当时符合条件的股票只有3个, 所以可以”买入”的就只有3个. (有没有发现到这个策略抓到了一个超级牛股 VITROX?) 事后想法在收笔前我们来做一个实验. 根据PE选股可靠吗?? 策略如下 Number of Stocks to buy : 10 Minimum ROE: 10我们就来看看, 在盈利能力(ROE)一样的情况下, 高PE和低PE的股票的表现. 高PE策略 低PE策略 回测结果也不用多说了, 低PE策略是明显的跑赢高PE策略. 可是这是一个很大概的概念而已, 不是所有高PE的股都不会涨. (就像TOPGLOVE从PE60涨到PE100++). 投资界大佬Howard Marks也说 “An overpriced stock doesn’t mean that it will drop tomorrow”, 意思是一个高估的股票不代表它明天就会掉. 股市里没有绝对, 可是从数据里我们也可以找到可以大概率跑赢的策略的. 不足之处这个网络程序也不是100%完美的, 也有一下不足的地方 没有技术分析的选项, 可能你的策略是要等MA, MACD黄金交叉的, 可是目前这个程序只能分析基本面. (如果反应好的话可能会加入技术分析选项, 需要时间和精力来开发哈哈) 没有考虑到交易费用. 如果你的本钱小的话, 交易费用会占你本金很大的比例. 好吧今天就到这里了, 如果有什么feedback可以在下面留言(不管是好是坏, 有feedback才能做得更好). 以上文章只供学习用途不是投资建议","link":"/zh-cn/Introduction-to-klsequant/"},{"title":"蜡烛图技术分析在马股有用吗? 胜率有多高?","text":"在股市/汇市有几年经验的朋友相信都知道什么是蜡烛图可是有没有想过蜡烛图在马股的胜率有多大呢? 到底蜡烛图是不是个可靠的指标? 介绍这里就不多加介绍蜡烛图的构造和历史了, 有兴趣的朋友可以上网搜索有关资讯, 而且有关资讯也相当丰富, 也不用我来介绍了. 研究方法小编用了Python编程程序来回测各个蜡烛图形在过去10年马股每一个个股的表现. 初始化我们需要pandas来处理庞大的数据和talib内建的蜡烛图标识功能.之后, 我们初始化一个我们想要测试的蜡烛图案的list. pandas as pd123456789101112131415161718import talibimport ospd.set_option(&apos;expand_frame_repr&apos;, False)pattern_name = [&apos;CDL2CROWS&apos;,&apos;CDL3BLACKCROWS&apos;,&apos;CDL3INSIDE&apos;,&apos;CDL3LINESTRIKE&apos;,&apos;CDL3OUTSIDE&apos;, &apos;CDL3STARSINSOUTH&apos;,&apos;CDL3WHITESOLDIERS&apos;,&apos;CDLABANDONEDBABY&apos;,&apos;CDLADVANCEBLOCK&apos;, &apos;CDLBELTHOLD&apos;,&apos;CDLBREAKAWAY&apos;,&apos;CDLCLOSINGMARUBOZU&apos;,&apos;CDLCONCEALBABYSWALL&apos;, &apos;CDLCOUNTERATTACK&apos;,&apos;CDLDARKCLOUDCOVER&apos;,&apos;CDLDOJI&apos;,&apos;CDLDOJISTAR&apos;, &apos;CDLDRAGONFLYDOJI&apos;,&apos;CDLENGULFING&apos;,&apos;CDLEVENINGDOJISTAR&apos;,&apos;CDLEVENINGSTAR&apos;, &apos;CDLGAPSIDESIDEWHITE&apos;,&apos;CDLGRAVESTONEDOJI&apos;,&apos;CDLHAMMER&apos;,&apos;CDLHANGINGMAN&apos;, &apos;CDLHARAMI&apos;,&apos;CDLHARAMICROSS&apos;,&apos;CDLHIGHWAVE&apos;,&apos;CDLHIKKAKE&apos;,&apos;CDLHIKKAKEMOD&apos;, &apos;CDLHOMINGPIGEON&apos;,&apos;CDLIDENTICAL3CROWS&apos;,&apos;CDLINNECK&apos;,&apos;CDLINVERTEDHAMMER&apos;,&apos;CDLKICKING&apos;, &apos;CDLKICKING&apos;,&apos;CDLKICKINGBYLENGTH&apos;,&apos;CDLLADDERBOTTOM&apos;,&apos;CDLLONGLEGGEDDOJI&apos;, &apos;CDLLONGLINE&apos;,&apos;CDLMARUBOZU&apos;,&apos;CDLMATCHINGLOW&apos;,&apos;CDLMATHOLD&apos;,&apos;CDLMORNINGDOJISTAR&apos;, &apos;CDLMORNINGSTAR&apos;,&apos;CDLONNECK&apos;,&apos;CDLPIERCING&apos;,&apos;CDLRICKSHAWMAN&apos;,&apos;CDLRISEFALL3METHODS&apos; &apos;CDLSEPARATINGLINES&apos;,&apos;CDLSHOOTINGSTAR&apos;,&apos;CDLSHORTLINE&apos;,&apos;CDLSPINNINGTOP&apos;, &apos;CDLSTALLEDPATTERN&apos;,&apos;CDLSTICKSANDWICH&apos;,&apos;CDLTAKURI&apos;,&apos;CDLTASUKIGAP&apos;,&apos;CDLTHRUSTING&apos;, &apos;CDLTRISTAR&apos;,&apos;CDLUNIQUE3RIVER&apos;,&apos;CDLUPSIDEGAP2CROWS&apos;,&apos;CDLXSIDEGAP3METHODS&apos;] 读取股市数据通常使用蜡烛图的都是短期交易者, 所以我测试的天数也较短.12345678910days = [1,5,10,30]path = os.getcwd()print(&apos;current working directory:&apos;,path)stock_code_list = []for root, dirs, files in os.walk(path): if files: for f in files: if &apos;.csv&apos; in f: stock_code_list.append(f.split(&apos;.csv&apos;)[0]) 开始分析代码写好后就开始让它工作吧！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657output = pd.DataFrame()final_output = pd.DataFrame(columns=[&apos;Pattern&apos;, &apos;Win Rate (1 Day)&apos;, &apos;Win Rate (5 Days)&apos;,&apos;Win Rate (10 Days)&apos;, &apos;Win Rate (30 Days)&apos;])for pattern in pattern_name: for code in stock_code_list: df = pd.read_csv(code + &apos;.csv&apos;, parse_dates=[1]) for i in days: df[&apos;Gains after &apos; + str(i) + &apos; days&apos;] = df[&apos;Close&apos;].shift(-i)/df[&apos;Close&apos;] - 1 df[pattern] = getattr(talib, pattern)(df[&apos;Open&apos;].astype(float).values, df[&apos;High&apos;].astype(float).values, df[&apos;Low&apos;].astype(float).values,df[&apos;Close&apos;].astype(float).values) pattern_df = df[df[pattern] != 0] output = output.append(pattern_df) try: bullish_output = output[output[pattern]&gt;0] OneDayWinRate = len(bullish_output.loc[bullish_output[&apos;Gains after 1 days&apos;] &gt; 0]) /\\ len(bullish_output[&apos;Gains after 1 days&apos;]) FiveDaysWinRate = len(bullish_output.loc[bullish_output[&apos;Gains after 5 days&apos;] &gt; 0]) /\\ len(bullish_output[&apos;Gains after 5 days&apos;]) TenDaysWinRate = len(bullish_output.loc[bullish_output[&apos;Gains after 10 days&apos;] &gt; 0]) /\\ len(bullish_output[&apos;Gains after 10 days&apos;]) ThirtyDaysWinRate = len(bullish_output.loc[bullish_output[&apos;Gains after 30 days&apos;] &gt; 0]) /\\ len(bullish_output[&apos;Gains after 30 days&apos;]) final_output = final_output.append({&apos;Pattern&apos;: &apos;Bullish &apos; + pattern, &apos;Win Rate (1 Day)&apos;: OneDayWinRate, &apos;Win Rate (5 Days)&apos;: FiveDaysWinRate, &apos;Win Rate (10 Days)&apos;: TenDaysWinRate, &apos;Win Rate (30 Days)&apos;: ThirtyDaysWinRate}, ignore_index=True) except Exception as e: print(&quot;No bullish pattern&quot;) try: bearish_output = output[output[pattern] &lt; 0] OneDayWinRate = len(bearish_output.loc[bearish_output[&apos;Gains after 1 days&apos;] &gt; 0]) / \\ len(bearish_output[&apos;Gains after 1 days&apos;]) FiveDaysWinRate = len(bearish_output.loc[bearish_output[&apos;Gains after 5 days&apos;] &gt; 0]) / \\ len(bearish_output[&apos;Gains after 5 days&apos;]) TenDaysWinRate = len(bearish_output.loc[bearish_output[&apos;Gains after 10 days&apos;] &gt; 0]) / \\ len(bearish_output[&apos;Gains after 10 days&apos;]) ThirtyDaysWinRate = len(bearish_output.loc[bearish_output[&apos;Gains after 30 days&apos;] &gt; 0]) / \\ len(bearish_output[&apos;Gains after 30 days&apos;]) final_output = final_output.append({&apos;Pattern&apos;: &apos;Bearish &apos; + pattern, &apos;Win Rate (1 Day)&apos;: OneDayWinRate, &apos;Win Rate (5 Days)&apos;: FiveDaysWinRate, &apos;Win Rate (10 Days)&apos;: TenDaysWinRate, &apos;Win Rate (30 Days)&apos;: ThirtyDaysWinRate}, ignore_index=True) except Exception as e: print(&quot;No bearish pattern&quot;) print(&apos;Done analysis on &apos; + pattern)print(final_output)final_output.to_csv(&apos;candlestick_analysis.csv&apos;,index=False) 结果程序计算了每个蜡烛图形在马股每一个个股在 (1,5,10,30) 天过后的表现. 0.7的表现就等于在10次出现该蜡烛图形后, 有7次股价是上涨的. 小编整理了一些数据并列出所有的蜡烛图案 神奇的是, 许多牛市信号都有着非常低的赢率, 个人推断是因为当大家都使用同一个信号的时候, 其获利能力将会大大减少. 其实以上的结果是出乎我的意料的, 因为没想到竟然很少指标有超过50%的胜率. 可是值得一提的是有些蜡烛图形有超过0.45的胜率. 如果配合其他的指标和风险管理的话这可能是可以持续性获利的交易指标. 想法这个回测程序也不是100%完美的, 一些弱点比如没有考虑蜡烛形态出现的地方 (有些形态是在低位/高位才比较有效的). 无论如何这次的研究也初步展示了蜡烛图形在马股的有效性和胜率. 或许蜡烛图形必须配合其他技术指标才能达到比较高的胜率. 值得一提的是, 0.2胜率的图形也可以当成反向指标来使用 (0.2的胜率代表图形出现后下跌的概率偏大) 这项研究的出发点是学习和探索用途. 交易自负","link":"/zh-cn/first-md/"},{"title":"你有听过72法则吗? 为什么是72? 不是71, 73?","text":"到底72法则是怎么来的? 数学家们为什么会用72这个数字呢 神奇的72法则相信大家多少都听过72法则吧. 72法则是一个方程式来让你计算你的投资要多久才会翻倍的方程式. 先来个例子, 如果一项投资能带来20%的回酬, 你需要多久才能翻倍? time = 72/x time = 72/20 time = 3.6 years如何证实? 1 x 1.2 x 1.2 x 1.2 x 1.2 = 2.07虽然不是100%准确, 可是用来估计是非常不错了 不知道你们有没有想过72这个数字是怎么来的呢?我们都知道, FV = PV x (1+x)^t FV = Future Value PV = Present Value r = return t = time如果我们要翻倍的话, 2PV = PV, 2PV = PV (1+r)^t 2 = (1+r)^t两边都加上natural logarithm ln(2) = t ln(1+r) t = ln(2) / ln(1+r)然后我们引用 taylor series expansion, $ln(1+r) = x - \\frac{x^2}{2} + \\frac{x^3}{3} - \\frac{x^4}{4} …..$(别叫我解释)如果r是足够小的话, 我们可以假设 ln(1+r) = r t = ln(2)/r t = 0.693/r为了容易计算, 我们把它 x100 t = 69.3/r可是答案不是72啊, 为什么呢? 看到这里是不是觉得被坑了如果我们用的是69, 69 只能被1,3,23,69除, 那么计算起来没那么方便如果我们用的是72, 72可以被1,2,3,4,6,8,12,18,24,36,72除, 可以很快的就算出答案 总结一下, 72法则是让我们可以快速计算一项投资的方程式. 虽然不是100%准确可是算出来的答案跟实际答案不会有太大偏差. 以下是72法则与实际答案的偏差","link":"/zh-cn/Rule-of-72/"},{"title":"定期定额投资股市每个月300, 10年.","text":"来一个系统性的分析定期定额投资法的可行性 什么是定期定额投资法?定期定额投资法是一个系统性的投资方法。他让你在低价时买得更多，高价时买得较少，长期来看你的平均价会比较好。 无论是股市还是基金都很多人都推崇这种投资法。 模拟方法小编先聚集的10年的股市数据，分别是美国标普500指数 (SP500), 新加坡股市 (SGX), 上证指数 and 大马综合指数 (KLSE)。 也用了EXCEL来模拟，每个月定定用RM300买入指数。 Results成绩出来是好坏都有。如果你买的是SP500指数，那么恭喜你，你的回酬会是70%。如果你买的是SGX或者KLSE，就会输掉20%。 小编又找数据又模拟，所以到底定期定额投资法管不管用呢? 结论 这里表明的是, RISK/REWARD还是值得，你用-20%的风险去换来70%的回酬。 分散投资对大众来说还是可行的。如果我们没有分析股市的能力（很多人都以为自己有的能力），那么分散投资还是一个可取的方案。 投资股市长期来说是很不错的，上面的模拟并没有考虑到你在大跌的时候加码买，如果大跌时再加码（前提是要该市场长期看好），那么等股市重新回到上升周期时，赚幅会更大 说了这么多，到底要怎样买指数？买完KLSE 30只股票吗？ 我们有2种选择，第一种是ETF。ETF会长期跟踪指数，所以他的表现基本上就是跟指数一样。 而且因为不用选股，手续费会比较低。 可是，在马来西亚，ETF的选择还是比较少，而且面对着交易量低，买/卖价太大（SPREADS)的问题。 另一个选项就是基金。 基金的话就没有ETF的问题，因为你想要卖的话，基金公司是必须跟你买回的，所以只是跟着NAV交易。 如果是ETF的话，你还要担心没有买盘，而且买盘低的话还可能卖不到好价钱。 在马来西亚，基金还是一个分散投资的一个好选项。 如果你想了解更多的话可以PM on Facebook Messenger或电邮至klsequant@gmail.com","link":"/zh-cn/RM300-a-year-for-10-years/"},{"title":"投资组合. All in 股票, All in 债券, 还是50/50?","text":"控制风险的同时如何确保够高的回酬? 什么是风险?人们常说”高风险, 高回酬”. 可是如果承受高的风险, 真的可以给你高回酬的话, 那这些投资还算是高风险吗? 我发现美国橡树资本的Howard Marks对风险的看法很有意思. 根据Howard Marks的说法, 当你承受高风险时, 你的回酬会承受更高的波动. 一图胜千言. 不同的资产等级有它们的风险等级. 股票型资产通常给人比较高风险的感觉, 股票型资产的回酬比较多不确定性, 有时候非常高, 有时候非常低甚至是负数, 主要的回酬范围在-20至50% (我们讨论的是大市而不是个股).因为很多变数可以影响股票的回酬, 市场情况, 公司盈利, 新的竞争者等. 反之债券型资产就比较低风险, 债券型资产回酬通常是非常低不确定性, 所以有时候债券也被称为fixed income asset.债券的主要风险在于公司/国家的倒闭, 无法偿还债券的利息或本金. 投资界大佬之一 John Bogle 的策略John Bogle 是 The Vanguard Group 的创办人, The Vanguard Group是美国数一数二的资产管理公司. 他投资的方法是把股票与债券分配至50/50的比例, 就是持有相同价值的股票与债券资产. 打个例子 股票 债券 5500 5100 此时你必须把RM400从股票资产转移至债券资产, 所以才符合50/50的原则. 这个方法的目的是要重新调整资产组合, 一个价钱高的资产有可能是被高估了, 所以需要套利并把资金移入另一个资产.反之如果股票资产的价钱低了, 你就需要把资金从债券移至股票, 趁股票资产被低估的时候买进. 分析方法我从morningstar的网站爬取的本地著名基金公司 “P公司” 的数据. 股票型基金我用的数据是 Global Equity Fund, East-Asia Equity Fund, Malaysia Index Fund. 选这3个基金的原因是因为它们可以很好的跟踪全球各国股市的表现.债券型基金我用的数据是 Enhanced Bond Fund. 数据的时间是从2006至2020, 以模拟长期投资的效果. 我用Python来计算各个rebalance, 资产增值的计算, 厉害用Excel的大神也可以用Excel, 只是我对Python比较熟悉所以用的是Python. 初始化我们需要pandas来做数据分析, 而seaborn及matplotlib用于数据可视化.12345678910import pandas as pdimport seaborn as snsimport matplotlib.pyplot as plt#read portfolio dataReturn = pd.DataFrame()p = pd.read_csv(&apos;Portfolio.csv&apos;, parse_dates=[&apos;Date&apos;])Return[&apos;Date&apos;] = p[&apos;Date&apos;]Return[&apos;Date&apos;] = pd.DatetimeIndex(Return[&apos;Date&apos;]).year.astype(float)print(p.head) 数据分析一些基本的逻辑算法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849def CalculateReturn(Equity,Bond,Investment): # Equity PGSF = 0.15 PIX = 0.15 PFES = 0.7 # Bond PBOND = 1.0 portfolio = pd.read_csv(&apos;Portfolio.csv&apos;, parse_dates=[&apos;Date&apos;]) EquityInvestment = Equity*Investment BondInvestment = Bond*Investment portfolio[&apos;PGSF Value&apos;] = &quot;&quot; portfolio[&apos;PIX Value&apos;] = &quot;&quot; portfolio[&apos;PFES Value&apos;] = &quot;&quot; portfolio[&apos;PBOND Value&apos;] = &quot;&quot; portfolio[&apos;Rebalanced E&apos;] = &quot;&quot; portfolio[&apos;Rebalanced B&apos;] = &quot;&quot; #first year value portfolio[&apos;PGSF Value&apos;][0] = EquityInvestment * PGSF * portfolio[&apos;PGSF&apos;][0] portfolio[&apos;PIX Value&apos;][0] = EquityInvestment * PIX * portfolio[&apos;PIX&apos;][0] portfolio[&apos;PFES Value&apos;][0] = EquityInvestment * PFES * portfolio[&apos;PFES&apos;][0] portfolio[&apos;PBOND Value&apos;][0] = BondInvestment * PBOND * portfolio[&apos;PBOND&apos;][0] portfolio[&apos;Rebalanced E&apos;][0] = portfolio[&apos;PGSF Value&apos;][0] + portfolio[&apos;PIX Value&apos;][0] + portfolio[&apos;PFES Value&apos;][0] portfolio[&apos;Rebalanced B&apos;][0] = portfolio[&apos;PBOND Value&apos;][0] for i in range(1,15): portfolio[&apos;PGSF Value&apos;][i] = portfolio[&apos;Rebalanced E&apos;][i-1] * PGSF * portfolio[&apos;PGSF&apos;][i] portfolio[&apos;PIX Value&apos;][i] = portfolio[&apos;Rebalanced E&apos;][i-1] * PIX * portfolio[&apos;PIX&apos;][i] portfolio[&apos;PFES Value&apos;][i] = portfolio[&apos;Rebalanced E&apos;][i-1] * PFES * portfolio[&apos;PFES&apos;][i] portfolio[&apos;PBOND Value&apos;][i] = portfolio[&apos;Rebalanced B&apos;][i-1] * PBOND * portfolio[&apos;PBOND&apos;][i] totalVal = portfolio[&apos;PGSF Value&apos;][i] + portfolio[&apos;PIX Value&apos;][i] + portfolio[&apos;PFES Value&apos;][i] + portfolio[&apos;PBOND Value&apos;][i] portfolio[&apos;Rebalanced E&apos;][i] = totalVal * Equity portfolio[&apos;Rebalanced B&apos;][i] = totalVal * Bond portfolio[&apos;Total&apos;] = portfolio[&apos;Rebalanced B&apos;] + portfolio[&apos;Rebalanced E&apos;] return portfolio[&apos;Total&apos;]Return[&apos;Equity&apos;] = CalculateReturn(1,0,20000).astype(float)Return[&apos;Bond&apos;] = CalculateReturn(0,1,20000).astype(float)Return[&apos;50/50 Equity/Bond&apos;] = CalculateReturn(0.5,0.5,20000).astype(float)print(Return) 输出完成数据分析后的数据可视化12345678910sns.set_style(&quot;darkgrid&quot;)p = sns.color_palette(&quot;hls&quot;, 8)ax = sns.lineplot(data=Return,y=&apos;Equity&apos;,x=&apos;Date&apos;,label=&quot;Full Equity&quot;, color=&apos;skyblue&apos;, marker=&apos;^&apos;,markeredgecolor=&quot;black&quot;,linewidth=5)ax = sns.lineplot(data=Return,y=&apos;Bond&apos;,x=&apos;Date&apos;,label=&quot;Full Bond&quot;,color=&apos;lightcoral&apos;,marker=&quot;x&quot;,markeredgecolor=&quot;black&quot;,linewidth=5)ax = sns.lineplot(data=Return,y=&apos;50/50 Equity/Bond&apos;,x=&apos;Date&apos;,color=&apos;palegreen&apos;,label=&quot;50/50 Equity/Bond&quot;,marker=&quot;o&quot;,markeredgecolor=&quot;black&quot;,linewidth=5)ax.set(xlabel=&quot;Date&quot;,ylabel=&quot;RM10k Invested&quot;)plt.legend()plt.show() 分析数据 满仓股票 满仓债券 50/50 股票/债券 回酬率 270% 105% 244% 2020年资产价值 27142 18664 24482 最低点 9971 10532 11191 如果你每年加码呢?我也计算了如果每年加码RM1000的结果, 就如预算的, 资产增值的速度会增快. 总结 不错的 风险/回酬 比例. 50/50组合可以在降低风险的情况下保持回酬. 分散风险不一定会牺牲高回酬. 50/50组合在更小的波动下只比股票型资产少赚了10% （大概RM2600) Rebalance不能太常进行, 必须考虑到手续费. 以上用的数据都是本地著名基金公司”P 公司”的数据. 如果你想了解更多的话可以PM on Facebook Messenger或电邮至klsequant@gmail.com","link":"/zh-cn/portfolio-construction-using-rebalancing/"},{"title":"用蒙特卡罗模拟法来看你的退休计划 💵💵","text":"用蒙特卡罗模拟法来看你的退休计划 背景有非常多的人对接下来的方法来策划他们的退休计划，先投资一笔钱，再每月定期定额投资，主要投资于股票市场 . 这个方法也被许多投资大佬所推崇，这就是所谓的“被动投资”。顾名思义就是不要去猜测市场高低位，有几率地定期定额的投资于股票市场。 我个人也是实行这个做法 讀讀。身为一名工程师，做任何决定前我都喜欢参考真实的数据，所以决定用蒙特卡洛模拟法的角度来分析这个做法。 Dow Jones 指数的历史回酬我选了Dow Jones指数来做分析，因为本人主要投资 美国市场，Dow Jones是美国股票市场的主要指数。 话不多说，先来点分析。 用 Pandas 模块来读取数据 我用的是1915年到2021年的数据。 12345678import pandas as pdimport numpy as npfrom scipy.stats import normimport matplotlib.pyplot as pltplt.style.use(&apos;seaborn&apos;)DJI = pd.read_csv(&apos;DJI.csv&apos;)DJI.head() .dataframe tbody tr th:only-of-type { vertical-align: middle; } .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Year Open High Low Close Adj. Close Return 0 2021 30,909.43 30,223.89 31,188.38 30,223.89 31,176.01 0.02 1 2020 26,890.67 28,868.80 30,606.48 18,591.93 30,606.48 0.07 2 2019 26,379.55 23,346.24 28,645.26 22,686.22 28,538.44 0.22 3 2018 25,046.86 24,824.01 26,828.39 21,792.20 23,327.46 -0.06 4 2017 21,750.20 19,881.76 24,837.51 19,732.40 24,719.22 0.25 一些统计学的分析 燐对于正态分布来说，95%的数据都会在2个标准差内。 虽然Dow Jones的历史回酬不是完美的正态分布，可是还是可以接受的。 正态分布的弱点就是忽略的黑天鹅的存在，这里就不多加讨论黑天鹅事件了。 1234567mean = DJI[&apos;Return&apos;].mean()std = DJI[&apos;Return&apos;].std()lowerbound = mean - 2*stdupperbound = mean + 2*stdprint(&quot;Mean return : {:.2f}&quot;.format(mean))print(&quot;Standard Deviation : {:.2f}&quot;.format(std)) Mean return : 0.08 Standard Deviation : 0.21Dow Jones 历史回酬的分布从数据我们算得平均数(mean)于标准差(standard deviation)。为了更好的可视化，把它画在图表上。 从图表来看，它的分布是接近于正态分布的。95% 的回酬都在 -33% 至 +49% 内。 1234567891011121314151617181920212223fig, ax1 = plt.subplots()ax2 = ax1.twinx()plt.axvline(x = upperbound, color=&apos;g&apos;, linestyle=&apos;-&apos;, alpha=0.5, label = &apos;mean&apos;)plt.axvline(x = lowerbound, color=&apos;g&apos;, linestyle=&apos;-&apos;, alpha=0.5, label = &apos;mean&apos;)#---------Histogram------------------------------------------------------------------------------------title = str(&apos;95% of Returns are in {:.2f}&apos;.format(1 + lowerbound) + &apos; and {:.2f}&apos;.format(1 + upperbound))DJI[&apos;Return&apos;].hist(bins=15, ax = ax1)ax1.set_ylabel(&apos;Probability&apos;)#---------Fitting the histogram with curve-------------------------------------------------------------mu, std = norm.fit(DJI[&apos;Return&apos;])xmin, xmax = plt.xlim()x = np.linspace(xmin, xmax, 100)p = norm.pdf(x, mu, std)ax2.plot(x, p, &apos;b&apos;, linewidth=2, alpha = 0.5)ax2.grid(False)ax2.set_ylabel(&apos;Distribution&apos;, color=&apos;b&apos;)#--------Show the plotplt.title(title)plt.show() 考存钱投资能成为百万富翁吗？ 我们来做个分析，假设一个人初始投资RM5000, 并每月定期定额投资RM400。 靠存钱的话他会存到RM168,200. 12345678910111213141516#-----Constants-----------------------INITIAL_INVESTMENT = 5000MONTHLY_TOPUP = 400YEARLY = MONTHLY_TOPUP * 12# ------------------------------------saving = [INITIAL_INVESTMENT]for i in range(1, 35): saving.append((saving[i - 1]) + YEARLY)capital = pd.DataFrame(saving, columns=[&apos;Saving&apos;])#------Plotting the savings growth------capital.plot(y=&apos;Saving&apos;, color=&apos;limegreen&apos;, alpha = 1)print(&apos;Final value : {:.2f}&apos;.format(capital[&apos;Saving&apos;].iloc[ -1])) Final value : 168200.00 蒙特卡罗模拟法RM168,200 在30年后可能有点少，如果加上投资呢？ 股票市场的回酬波动大而且不确定性高，不过对于刚刚我们已经有了一定的分析，95% 的回酬是在 -33% 至 +49% 内的。 利用蒙特卡罗模拟法，我模拟了50次不同的结果。 这就像是奇特博士在复3里做的事一样, 差别在于我用程序来模拟。 最后我会用各个结果的中位数来做比较。中位数比平均数更能表现出真实的表现，因为中位数较不受极端数位影响。 12345678910111213141516171819202122232425262728from random import randrange#-----Using upperbound and lowerbound of historical returns-------RAND_TOP = 149RAND_BOT = 68YEAR = 34#------Generate 50 simulations------------------------------------for k in range(1, 50): capital[str(&apos;Capital&apos; + str(k))] = capital[&apos;Saving&apos;] for i in range(1, len(capital)): capital.loc[i, str(&apos;Capital&apos; + str(k))] = (capital.loc[i - 1, str(&apos;Capital&apos; + str(k))] + YEARLY) * float( randrange(RAND_BOT, RAND_TOP) / 100)capital[&apos;Mean&apos;] = capital.median(axis=1)fig = plt.figure(figsize=(12, 6))fig.suptitle((&apos;Average Return after &apos; + str(YEAR) + &apos; Years is %.2f&apos; % capital[&apos;Mean&apos;][capital.index[YEAR]]))ax = fig.add_subplot(121)ax2 = fig.add_subplot(122)capital.plot(legend=None,alpha=0.3, title = &apos;Monte Carlo Simulations&apos;, xlabel = &apos;Years&apos;, ylabel = &apos;RM&apos;, ax = ax)capital.iloc[-1].hist(bins=20, orientation=&quot;horizontal&quot;, color=&quot;pink&quot;, alpha=0.5,ax = ax)capital.plot(y=&apos;Saving&apos;, color = &apos;tomato&apos;, alpha = 1, label=&quot;Savings&quot;, xlabel = &apos;Years&apos;, ylabel = &apos;RM&apos;, title = &apos;Median of simulations&apos;, ax = ax2)capital.plot(y=&apos;Mean&apos;, color=&apos;limegreen&apos;, alpha = 1, ax = ax2)plt.show() 笔记 ⚡⚡这模拟每次运行都会产生不同的答案，因为有程序里加了随机的因素。 或许在几个模拟中你会成为百万富翁，根据中位数来看，最可能的结果是你将得到 RM500,000 的净值。（也不错?) 想要成为百万富翁，迎娶白富美，走上人生巅峰的话，看来你得更努力存钱投资了。","link":"/zh-cn/montecarlosimulation/"},{"title":"我们正式登陆Android啦！","text":"我们正式登陆Android啦！ 这是什么？klsequant 从面世至今都是以web app形式来招呼大家的。 要分析大量财务数据的话，使用Python是远远比在手机上的Java容易的，而且在手机上分析也需要大量内存和空间来存储数据，所以一开始并没有推出Android版本的。 klsequant 是我的 hobby project之一，目的在于帮助大家测试选股策略，大师们都说好的低PE高ROE，用klsequant就能帮你找出这个策略的有效性。 一些技术细节这程序是用Android Studio来写的，然后也用了flask API来用我们在pythonanywhere上的程序来做运算，所以所有的运算都是在云端上进行的。 这要怎么用？如果你刚接触这个网站，别担心，我们有一篇博文是教你怎么使用的。Android版和web版是一样使用逻辑。 Where can you download 想要测试选股策略的朋友可以到 Google Play 去下载。","link":"/zh-cn/we-are-now-on-android/"}],"tags":[{"name":"Backtesting","slug":"Backtesting","link":"/zh-cn/tags/Backtesting/"},{"name":"Stock Picking","slug":"Stock-Picking","link":"/zh-cn/tags/Stock-Picking/"},{"name":"Python","slug":"Python","link":"/zh-cn/tags/Python/"},{"name":"蜡烛图","slug":"蜡烛图","link":"/zh-cn/tags/%E8%9C%A1%E7%83%9B%E5%9B%BE/"},{"name":"Maths","slug":"Maths","link":"/zh-cn/tags/Maths/"},{"name":"Strategy","slug":"Strategy","link":"/zh-cn/tags/Strategy/"},{"name":"Monte Carlo","slug":"Monte-Carlo","link":"/zh-cn/tags/Monte-Carlo/"},{"name":"Investment","slug":"Investment","link":"/zh-cn/tags/Investment/"}],"categories":[]}